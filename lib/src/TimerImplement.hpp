/*
 * TimerImplement.hpp
 *
 *  Created on: Nov 30, 2014
 *      Author: wilsan
 */

#ifndef TIMERIMPLEMENT_HPP_
#define TIMERIMPLEMENT_HPP_

#include "../common.hpp"
#include "../memorymap/MapTimer.hpp"
#include "../include/Timer.hpp"

#define TIMERMAP(x) ( reinterpret_cast<MapTimer::TimerRegs*>( x ) )

namespace Timer
{
    TimeEvent::TimeEvent( instance::_instance timer,
                          channel::_channel channel )
    {
        m_timer   = timer; 
        m_channel = channel;
    }

    void TimeEvent::stop()
    {
        volatile u16 _reg = TIMERMAP( m_timer )->TxyCTL;
        _reg &= ( 0xffff - ( 0x3 << 4 ) );
        TIMERMAP( m_timer )->TxyCTL = _reg | ( config::countMode::STOP_MODE );
    }

    void TimeEvent::config( u16 calcPeriod_ms, 
                            config::clockMainDivider::_clockMainDivider pClockMainDivider, 
                            config::clockSubDivider::_clockSubDivider pClockSubDivider,
                            config::clockSource::_clockSource pClockSource,
                            config::countMode::_countMode pCountMode )
    {
        TIMERMAP( m_timer )->TxyCTL = pClockSource | pClockMainDivider |
                                      pCountMode;

        TIMERMAP( m_timer )->TxyEX0 = pClockSubDivider;        

        TIMERMAP( m_timer + 2 * m_channel )->TxyCCR0 = calcPeriod_ms;
    }

    void TimeEvent::restart() 
    {
        TIMERMAP( m_timer )->TxyCTL |= ( 1 << 2 );
    }

    void TimeEvent::enableInterrupt()
    {
        // TODO: Check what is this interrupt for
        //TIMERMAP( m_timer )->TxyCTL |= ( 1 << 1 );

        TIMERMAP( m_timer + 2 * m_channel )->TxyCCTL0 |= ( 1 << 4 );
    }

    bool TimeEvent::isInterruptPending()
    {
        return false;
    }

    u16 TimeEvent::getTimerReg()
    {
    	return TIMERMAP( m_timer )->TxyR;
    }

    void TimeEvent::setTimerReg( u16 pTimerValue )
    {
    	TIMERMAP( m_timer )->TxyR = pTimerValue;
    }

    Pwm::Pwm( instance::_instance pTimer,
              channel::_channel pChannel )
    {
        m_timer = pTimer;
        m_channel = pChannel;
        m_period = 1;
        m_duty = 0;
    }

    void Pwm::stop()
    {
        volatile u16 _reg = TIMERMAP( m_timer )->TxyCTL;
        _reg &= ( 0xffff - ( 0x3 << 4 ) );
        TIMERMAP( m_timer )->TxyCTL = _reg | ( config::countMode::STOP_MODE );
    }

    void Pwm::config( u16 pCalcPeriod,
                      float pInitDuty,        
                      config::clockMainDivider::_clockMainDivider pCalcMainDivider,
                      config::clockSubDivider::_clockSubDivider pCalcSubDivider,
                      config::clockSource::_clockSource pClockSource )
    {
        // This abstraction uses the timer in CC-outputMode 7 and the pwms are ...
        // generated by the timer channel 0 along the corresponding channels used for ...
        // each pwm

        TIMERMAP( m_timer )->TxyCTL = pClockSource | pCalcMainDivider |
                                      config::countMode::UP_MODE;
        TIMERMAP( m_timer )->TxyEX0 = pCalcSubDivider;

        // In pwm mode, let's use outputt mode 7
        // Just take into account that the period ...
        // is given by TAxCCR0 and the duty by TAxCCRy
        // ( y >= 1 ) for outputt mode 7

        // TODO: There must be a way to say the user that ...
        // he shouldn't use channel 0 ( an assert or something )
        // Load the period in channel 0
        TIMERMAP( m_timer )->TxyCCR0 = m_period = pCalcPeriod;

        // Normalize the duty cycle ( just in case )
        pInitDuty = ( pInitDuty < 0 ) ? 0 : pInitDuty;
        m_duty = pInitDuty * m_period;
        m_duty = ( m_duty > m_period ) ? m_period : m_duty;
        // Load the duty cycle in the corresponding channel
        TIMERMAP( m_timer + 2 * m_channel )->TxyCCR0 = m_duty;
        // Configure the ccp channel for the configuration we want
        TIMERMAP( m_timer + 2 * m_channel )->TxyCCTL0 = config::captureMode::NO_CAPTURE |
                                                        config::captureInput::GND |
                                                        config::ccMode::COMPARE | 
                                                        config::outputMode::RESET_SET; 
        // Restart the timer
        TIMERMAP( m_timer )->TxyCTL |= ( 1 << 2 );
    }

    void Pwm::setDuty( float pCalcDuty )
    {
        pCalcDuty = ( pCalcDuty < 0 ) ? 0 : pCalcDuty;
        m_duty = pCalcDuty * m_period;
        m_duty = ( m_duty > m_period ) ? m_period : m_duty; 

        TIMERMAP( m_timer + 2 * m_channel )->TxyCCR0 = m_duty;
    }
}



#endif /* TIMERIMPLEMENT_HPP_ */
